<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cybersecurity Atlas</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #030712;
      --bg-alt: radial-gradient(circle at top, rgba(30, 64, 175, 0.35), transparent 55%),
        radial-gradient(circle at bottom, rgba(234, 88, 12, 0.28), transparent 60%),
        #030712;
      --panel: rgba(15, 23, 42, 0.8);
      --panel-solid: #0f172a;
      --border: rgba(148, 163, 184, 0.18);
      --border-strong: rgba(226, 232, 240, 0.32);
      --accent: #f97316;
      --accent-soft: rgba(249, 115, 22, 0.18);
      --text: #f8fafc;
      --muted: #94a3b8;
      --chip-bg: rgba(249, 115, 22, 0.16);
      --chip-text: #fb923c;
      --glass: rgba(15, 23, 42, 0.65);
    }

    :root[data-theme="light"] {
      color-scheme: light;
      --bg: #f8fafc;
      --bg-alt: radial-gradient(circle at top, rgba(248, 250, 252, 0.85), transparent 55%),
        #eef2ff;
      --panel: rgba(255, 255, 255, 0.88);
      --panel-solid: #ffffff;
      --border: rgba(148, 163, 184, 0.35);
      --border-strong: rgba(30, 64, 175, 0.32);
      --accent: #ea580c;
      --accent-soft: rgba(234, 88, 12, 0.16);
      --text: #0f172a;
      --muted: #475569;
      --chip-bg: rgba(234, 88, 12, 0.1);
      --chip-text: #c2410c;
      --glass: rgba(255, 255, 255, 0.75);
    }

    * {
      box-sizing: border-box;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: var(--bg);
      color: var(--text);
      position: relative;
      display: flex;
      flex-direction: column;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background: var(--bg-alt);
      z-index: -2;
    }

    body::after {
      content: "";
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at center, rgba(255, 255, 255, 0.06), transparent 60%);
      pointer-events: none;
      z-index: -1;
    }

    header {
      padding: 1.4rem clamp(1.25rem, 3vw, 2.5rem);
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      gap: 1.5rem;
      backdrop-filter: blur(18px);
      background: linear-gradient(135deg, rgba(15, 23, 42, 0.55), transparent 55%);
    }

    header .brand {
      display: grid;
      gap: 0.45rem;
    }

    header h1 {
      font-size: clamp(1.5rem, 2vw, 1.9rem);
      letter-spacing: 0.01em;
      margin: 0;
    }

    header p {
      margin: 0;
      color: var(--muted);
      font-size: 0.9rem;
      max-width: 36ch;
    }

    header .controls {
      display: inline-flex;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    button,
    input {
      font: inherit;
      border-radius: 999px;
      border: 1px solid transparent;
      padding: 0.5rem 1rem;
      background: var(--panel);
      color: var(--text);
      transition: border 160ms ease, background 160ms ease, transform 160ms ease;
    }

    button:hover,
    input:focus-visible {
      border-color: var(--accent);
      outline: none;
    }

    button:active {
      transform: translateY(1px);
    }

    button.toggle {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      cursor: pointer;
      background: var(--accent-soft);
      color: var(--accent);
      border-color: transparent;
      box-shadow: 0 12px 28px rgba(249, 115, 22, 0.1);
    }

    main {
      flex: 1;
      width: min(1200px, 100%);
      margin: clamp(1.5rem, 3vw, 3rem) auto clamp(1.5rem, 3vw, 3rem);
      display: grid;
      grid-template-columns: minmax(280px, 360px) 1fr;
      gap: clamp(1.1rem, 2vw, 1.6rem);
      padding: clamp(1rem, 2vw, 1.8rem);
      border-radius: 28px;
      background: linear-gradient(135deg, rgba(148, 163, 184, 0.08), rgba(30, 41, 59, 0.35));
      border: 1px solid rgba(148, 163, 184, 0.12);
      box-shadow: 0 24px 60px rgba(15, 23, 42, 0.35);
      backdrop-filter: blur(24px);
    }

    aside {
      background: var(--glass);
      border: 1px solid var(--border);
      border-radius: 22px;
      padding: clamp(1rem, 2vw, 1.6rem);
      display: flex;
      flex-direction: column;
      gap: 1rem;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.06);
      backdrop-filter: blur(24px);
    }

    aside[data-collapsed="true"] .panel-content {
      display: none;
    }

    aside[data-collapsed="true"] {
      padding-bottom: clamp(0.5rem, 1.5vw, 0.9rem);
    }

    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
    }

    #panel-toggle {
      background: rgba(148, 163, 184, 0.22);
      color: var(--text);
      border-radius: 0.85rem;
      padding: 0.35rem 0.75rem;
      font-size: 0.82rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    #panel-toggle:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    aside .panel-content {
      display: flex;
      flex-direction: column;
      gap: 1.4rem;
      overflow-y: auto;
      max-height: min(62vh, 540px);
      padding-right: 0.2rem;
    }

    aside .panel-content::-webkit-scrollbar {
      width: 10px;
    }

    aside .panel-content::-webkit-scrollbar-thumb {
      background: rgba(148, 163, 184, 0.28);
      border-radius: 999px;
    }

    aside .panel-content::-webkit-scrollbar-thumb:hover {
      background: rgba(249, 115, 22, 0.45);
    }

    .panel-title {
      margin: 0;
      color: var(--muted);
      font-size: 0.75rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
    }

    .status-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.3rem 0.85rem;
      border-radius: 999px;
      background: var(--chip-bg);
      color: var(--chip-text);
      font-size: 0.82rem;
      width: fit-content;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .log {
      font-size: 0.85rem;
      color: var(--muted);
      border-radius: 16px;
      background: rgba(15, 23, 42, 0.45);
      border: 1px solid rgba(148, 163, 184, 0.12);
      padding: 0.75rem;
      display: grid;
      gap: 0.4rem;
      max-height: 220px;
      overflow-y: auto;
    }

    .log::-webkit-scrollbar {
      width: 6px;
    }

    .log::-webkit-scrollbar-thumb {
      background: rgba(148, 163, 184, 0.26);
      border-radius: 999px;
    }

    #graph-wrapper {
      position: relative;
      border-radius: 26px;
      border: 1px solid var(--border);
      background: linear-gradient(160deg, rgba(30, 41, 59, 0.75), rgba(15, 23, 42, 0.65));
      overflow: hidden;
      box-shadow: 0 22px 55px rgba(15, 23, 42, 0.45);
      isolation: isolate;
    }

    #graph-wrapper::after {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 25% 20%, rgba(249, 115, 22, 0.18), transparent 55%),
        radial-gradient(circle at 75% 80%, rgba(14, 165, 233, 0.18), transparent 52%);
      pointer-events: none;
      mix-blend-mode: screen;
    }

    #graph-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }

    #loading-indicator {
      position: absolute;
      inset: 0;
      display: grid;
      place-content: center;
      background: linear-gradient(135deg, rgba(15, 23, 42, 0.82), rgba(15, 23, 42, 0.62));
      color: var(--muted);
      font-size: 0.95rem;
      letter-spacing: 0.04em;
      transition: opacity 220ms ease;
    }

    #loading-indicator[data-hidden="true"] {
      opacity: 0;
      pointer-events: none;
    }

    .node-meta {
      display: grid;
      gap: 0.6rem;
      padding: 1rem 1.1rem;
      border-radius: 18px;
      background: rgba(15, 23, 42, 0.45);
      border: 1px solid rgba(148, 163, 184, 0.1);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }

    .node-meta h2 {
      margin: 0;
      font-size: 1.12rem;
      letter-spacing: 0.01em;
    }

    .node-meta dl {
      margin: 0;
      display: grid;
      gap: 0.45rem;
      font-size: 0.92rem;
    }

    .node-meta dt {
      color: var(--muted);
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      font-size: 0.7rem;
    }

    .node-meta dd {
      margin: 0;
      color: var(--text);
      font-size: 0.95rem;
    }

    .search-box {
      display: grid;
      gap: 0.55rem;
    }

    .search-box label {
      font-size: 0.78rem;
      color: var(--muted);
      letter-spacing: 0.1em;
      text-transform: uppercase;
    }

    .search-results {
      display: grid;
      gap: 0.4rem;
      font-size: 0.85rem;
    }

    .search-results button {
      justify-content: flex-start;
      text-align: left;
      border-radius: 0.85rem;
      padding: 0.45rem 0.75rem;
      background: rgba(15, 23, 42, 0.35);
      border-color: rgba(148, 163, 184, 0.16);
      color: inherit;
      transition: transform 160ms ease, border-color 160ms ease, color 160ms ease;
    }

    .search-results button:hover {
      border-color: var(--border-strong);
      color: var(--accent);
      transform: translateX(4px);
    }

    .favorites {
      display: grid;
      gap: 0.55rem;
    }

    .favorites header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }

    .favorites h3 {
      margin: 0;
      font-size: 0.8rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
    }

    #favorite-list {
      display: grid;
      gap: 0.35rem;
    }

    #favorite-list button {
      justify-content: flex-start;
      text-align: left;
      padding: 0.4rem 0.7rem;
      border-radius: 0.85rem;
      background: rgba(15, 23, 42, 0.35);
      border-color: rgba(148, 163, 184, 0.18);
      color: inherit;
    }

    #favorite-list button:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    .accessibility {
      display: grid;
      gap: 0.4rem;
    }

    .accessibility label {
      font-size: 0.78rem;
      color: var(--muted);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .accessibility input[type="range"] {
      width: 100%;
    }

    @media (prefers-reduced-motion: reduce) {
      *,
      *::before,
      *::after {
        transition-duration: 0ms !important;
      }
    }

    @media (max-width: 960px) {
      main {
        grid-template-columns: 1fr;
        grid-template-rows: minmax(260px, 45vh) 1fr;
      }

      aside {
        order: 2;
      }

      #graph-wrapper {
        min-height: 260px;
      }
    }

    @media (max-width: 720px) {
      header {
        flex-direction: column;
        align-items: flex-start;
      }

      header .controls {
        width: 100%;
      }

      main {
        padding: 1.1rem;
      }
    }
  </style>
</head>
<body>
  <header>
    <div class="brand">
      <span class="status-chip">Cyber Notes &amp; Future Tech</span>
      <h1>Cybersecurity Atlas</h1>
      <p>Explore a living map of the information security landscape — curated for fast orientation and deep dives.</p>
    </div>
    <div class="controls">
      <button id="theme-toggle" class="toggle" type="button" aria-pressed="true">🌗 Theme</button>
      <button id="reset-view" type="button">Reset view</button>
    </div>
  </header>
  <main>
    <aside data-collapsed="false">
      <div class="panel-header">
        <span class="status-chip" style="margin:0;">Navigator</span>
        <button id="panel-toggle" type="button" aria-expanded="true">Collapse</button>
      </div>
      <div class="panel-content">
      <section class="search-box">
        <label for="search-input">Search topics</label>
        <input id="search-input" type="search" placeholder="Start typing…" autocomplete="off" />
        <div id="search-results" class="search-results" role="listbox" aria-label="Matching topics"></div>
      </section>
      <section class="node-meta" aria-live="polite">
        <h2 id="node-title">Loading…</h2>
        <dl>
          <div>
            <dt>Hierarchy</dt>
            <dd id="node-path">—</dd>
          </div>
          <div>
            <dt>Children</dt>
            <dd id="node-children">—</dd>
          </div>
        </dl>
        <button id="favorite-toggle" type="button" aria-pressed="false" style="justify-self:start;">☆ Save to favourites</button>
      </section>
      <section class="favorites">
        <header>
          <h3>Favourites</h3>
          <button id="clear-favorites" type="button" style="font-size:0.7rem;letter-spacing:0.08em;text-transform:uppercase;padding:0.25rem 0.6rem;">Clear</button>
        </header>
        <div id="favorite-list" role="listbox" aria-label="Favourite topics"></div>
      </section>
      <section class="accessibility">
        <label for="font-scale">Label size</label>
        <input id="font-scale" type="range" min="0.85" max="1.35" step="0.05" value="1" />
      </section>
      <section>
        <h3 style="margin:0;font-size:0.9rem;color:var(--muted);text-transform:uppercase;letter-spacing:0.05em;">Activity</h3>
        <div id="activity-log" class="log" aria-live="polite"></div>
      </section>
      </div>
    </aside>
    <div id="graph-wrapper">
      <canvas id="graph-canvas" role="application" aria-label="Cybersecurity Atlas graph"></canvas>
      <div id="loading-indicator">Preparing atlas…</div>
    </div>
  </main>
  <script>
  (function() {
    const themeToggle = document.getElementById('theme-toggle');
    const resetViewBtn = document.getElementById('reset-view');
    const panelToggle = document.getElementById('panel-toggle');
    const favoriteToggle = document.getElementById('favorite-toggle');
    const favoriteList = document.getElementById('favorite-list');
    const clearFavorites = document.getElementById('clear-favorites');
    const fontScaleInput = document.getElementById('font-scale');
    const sidePanel = document.querySelector('aside');
    favoriteToggle.disabled = true;
    const loadingIndicator = document.getElementById('loading-indicator');
    const activityLog = document.getElementById('activity-log');
    const nodeTitle = document.getElementById('node-title');
    const nodePath = document.getElementById('node-path');
    const nodeChildren = document.getElementById('node-children');
    const searchInput = document.getElementById('search-input');
    const searchResults = document.getElementById('search-results');

    class Graph {
      constructor() {
        this.nodes = new Map();
        this.edges = new Map();
        this.outgoing = new Map();
      }

      addNode(id, attrs) {
        if (this.nodes.has(id)) return;
        this.nodes.set(id, {...attrs});
        nodeMetrics.delete(id);
        if (!this.outgoing.has(id)) {
          this.outgoing.set(id, new Set());
        }
      }

      hasNode(id) {
        return this.nodes.has(id);
      }

      getNodeAttributes(id) {
        return this.nodes.get(id);
      }

      setNodeAttributes(id, nextAttrs) {
        if (!this.nodes.has(id)) return;
        Object.assign(this.nodes.get(id), nextAttrs);
        nodeMetrics.delete(id);
      }

      addEdge(source, target, attrs = {}) {
        const key = `${source}→${target}`;
        if (this.edges.has(key)) return;
        this.edges.set(key, {source, target, attrs: {...attrs}});
        if (!this.outgoing.has(source)) {
          this.outgoing.set(source, new Set());
        }
        this.outgoing.get(source).add(target);
      }

      hasEdge(source, target) {
        return this.edges.has(`${source}→${target}`);
      }

      outDegree(id) {
        return this.outgoing.get(id)?.size ?? 0;
      }

      forEachNode(callback) {
        this.nodes.forEach((attrs, id) => callback(id, attrs));
      }

      forEachEdge(callback) {
        this.edges.forEach(({source, target, attrs}) => callback(source, target, attrs));
      }
    }

    const graph = new Graph();
    const wrapper = document.getElementById('graph-wrapper');
    const canvas = document.getElementById('graph-canvas');
    const ctx = canvas.getContext('2d');

    const nodeMetrics = new Map();
    const favorites = new Set(JSON.parse(localStorage.getItem('atlas-favorites') || '[]'));
    let labelScale = parseFloat(localStorage.getItem('atlas-label-scale') || '1');
    if (!Number.isFinite(labelScale)) {
      labelScale = 1;
    }
    labelScale = Math.min(1.35, Math.max(0.85, labelScale));

    const layoutConfig = {
      childrenPerRing: 6,
      baseLinkDistance(depth) {
        if (depth <= 0) return 0;
        if (depth === 1) return 100;
        if (depth === 2) return 130;
        return 130 + (depth - 2) * 25;
      },
      ringMultiplier(depth) {
        if (depth <= 1) return 1.6;
        if (depth <= 3) return 2.1;
        return 2.4;
      }
    };

    const FONT_FAMILY = '"Inter", "Segoe UI", system-ui, sans-serif';
    const BOX_PADDING_X = 16;
    const BOX_PADDING_Y = 12;
    const LINE_HEIGHT = 18;
    const MAX_LABEL_WIDTH = 280;

    let viewWidth = 0;
    let viewHeight = 0;
    let rootId = null;
    const camera = {x: 0, y: 0, scale: 0.6};
    let hoveredNode = null;
    let selectedNode = null;
    let flashNode = null;
    let flashUntil = 0;
    let isDragging = false;
    let dragPointerId = null;
    let pointerMoved = false;
    let lastPointer = {x: 0, y: 0};
    let lastHoverPoint = {x: 0, y: 0};
    let needsRender = true;

    const pendingLoads = new Map();
    const loadedBranches = new Set();
    const searchIndex = new Map();
    let searchMatches = new Set();

    const palette = [
      '#38bdf8', '#f59e0b', '#a855f7', '#22c55e', '#ef4444', '#ec4899', '#0ea5e9', '#f97316'
    ];

    function log(message) {
      const entry = document.createElement('div');
      entry.textContent = message;
      activityLog.prepend(entry);
      while (activityLog.childElementCount > 12) {
        activityLog.removeChild(activityLog.lastElementChild);
      }
    }

    function requestRender() {
      needsRender = true;
    }

    function persistFavorites() {
      localStorage.setItem('atlas-favorites', JSON.stringify([...favorites]));
    }

    function updateFavoritesUI() {
      favoriteList.innerHTML = '';
      clearFavorites.disabled = favorites.size === 0;
      if (!favorites.size) {
        const empty = document.createElement('div');
        empty.textContent = 'No favourites yet';
        empty.style.color = 'var(--muted)';
        empty.style.fontSize = '0.8rem';
        favoriteList.append(empty);
        return;
      }
      const items = [...favorites].map(id => {
        const label = searchIndex.get(id)?.label || graph.getNodeAttributes(id)?.label || id;
        return {id, label, display: inlineLabel(label)};
      }).sort((a, b) => a.display.localeCompare(b.display));
      items.forEach(item => {
        if (!graph.hasNode(item.id)) {
          const notice = document.createElement('div');
          notice.textContent = `${item.display} (load branch to view)`;
          notice.style.color = 'var(--muted)';
          notice.style.fontSize = '0.78rem';
          favoriteList.append(notice);
          return;
        }
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.setAttribute('role', 'option');
        btn.textContent = item.display;
        btn.addEventListener('click', () => {
          animateToNode(item.id);
          updateNodeDetails(item.id);
          flashNode = item.id;
          flashUntil = performance.now() + 1200;
          ensureBranchLoaded(item.id).then(() => populateSearch());
          requestRender();
        });
        favoriteList.append(btn);
      });
    }

    function resizeCanvas() {
      const rect = wrapper.getBoundingClientRect();
      viewWidth = rect.width;
      viewHeight = rect.height;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.max(1, Math.floor(viewWidth * dpr));
      canvas.height = Math.max(1, Math.floor(viewHeight * dpr));
      canvas.style.width = `${viewWidth}px`;
      canvas.style.height = `${viewHeight}px`;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      requestRender();
    }

    const renderLoop = () => {
      if (needsRender) {
        draw();
        needsRender = false;
      }
      requestAnimationFrame(renderLoop);
    };

    function worldToScreen(x, y) {
      return {
        x: (x - camera.x) * camera.scale + viewWidth / 2,
        y: (y - camera.y) * camera.scale + viewHeight / 2,
      };
    }

    function screenToWorld(x, y) {
      return {
        x: (x - viewWidth / 2) / camera.scale + camera.x,
        y: (y - viewHeight / 2) / camera.scale + camera.y,
      };
    }

    function labelFont() {
      return `${(12 * labelScale).toFixed(2)}px ${FONT_FAMILY}`;
    }

    function wrapLines(paragraph) {
      const tokens = paragraph.split(/\s+/).filter(Boolean);
      if (!tokens.length) return [''];
      const lines = [];
      let current = tokens.shift();
      tokens.forEach(token => {
        const tentative = current ? `${current} ${token}` : token;
        if (ctx.measureText(tentative).width > MAX_LABEL_WIDTH && current) {
          lines.push(current);
          current = token;
        } else {
          current = tentative;
        }
      });
      if (current) {
        lines.push(current);
      }
      return lines;
    }

    function inlineLabel(text) {
      return (text || '').replace(/\s*\n\s*/g, ' · ');
    }

    function getNodeMetrics(id, attrs) {
      const label = attrs.label || attrs.name || id;
      const cached = nodeMetrics.get(id);
      if (cached && cached.scale === labelScale && cached.label === label) {
        return cached.metrics;
      }
      ctx.save();
      ctx.font = labelFont();
      const segments = label.split(/\n+/);
      const lines = [];
      segments.forEach((segment, index) => {
        const trimmed = segment.trim();
        if (!trimmed) {
          if (index !== segments.length - 1) {
            lines.push('');
          }
          return;
        }
        wrapLines(trimmed).forEach(line => lines.push(line));
      });
      if (!lines.length) {
        lines.push(label || id);
      }
      let maxWidth = 0;
      lines.forEach(line => {
        maxWidth = Math.max(maxWidth, ctx.measureText(line).width);
      });
      const paddingX = BOX_PADDING_X * labelScale;
      const paddingY = BOX_PADDING_Y * labelScale;
      const lineHeight = LINE_HEIGHT * labelScale;
      const metrics = {
        label,
        lines,
        width: maxWidth + paddingX * 2,
        height: lines.length * lineHeight + paddingY * 2,
        paddingX,
        paddingY,
        lineHeight,
      };
      ctx.restore();
      nodeMetrics.set(id, {scale: labelScale, label, metrics});
      return metrics;
    }

    function findNodeAt(x, y) {
      const world = screenToWorld(x, y);
      let found = null;
      let minDepth = Infinity;
      graph.forEachNode((id, attrs) => {
        const metrics = getNodeMetrics(id, attrs);
        const left = attrs.x - metrics.width / 2;
        const top = attrs.y - metrics.height / 2;
        if (world.x >= left && world.x <= left + metrics.width && world.y >= top && world.y <= top + metrics.height) {
          const depth = attrs.depth || 0;
          if (depth <= minDepth) {
            minDepth = depth;
            found = id;
          }
        }
      });
      return found;
    }

    function hexToRgb(hex) {
      const match = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      if (!match) return {r: 148, g: 163, b: 184};
      return {
        r: parseInt(match[1], 16),
        g: parseInt(match[2], 16),
        b: parseInt(match[3], 16),
      };
    }

    function rgba(rgb, alpha) {
      return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
    }

    function drawRoundedRect(x, y, width, height, radius) {
      const r = Math.min(radius, width / 2, height / 2);
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + width, y, x + width, y + height, r);
      ctx.arcTo(x + width, y + height, x, y + height, r);
      ctx.arcTo(x, y + height, x, y, r);
      ctx.arcTo(x, y, x + width, y, r);
      ctx.closePath();
    }

    function computeNodeColors(id, attrs, themeText, themeMuted) {
      const baseHex = attrs.color || '#38bdf8';
      const rgb = hexToRgb(baseHex);
      if (searchMatches.size && !searchMatches.has(id)) {
        const muted = {r: 148, g: 163, b: 184};
        return {
          stroke: rgba(muted, 0.25),
          fill: rgba(muted, 0.14),
          text: themeMuted || 'rgba(148, 163, 184, 0.7)',
        };
      }
      if (id === hoveredNode) {
        const hover = hexToRgb('#f97316');
        return {stroke: rgba(hover, 0.95), fill: rgba(hover, 0.22), text: '#f8fafc'};
      }
      if (id === selectedNode) {
        const sel = hexToRgb('#fb7185');
        return {stroke: rgba(sel, 0.95), fill: rgba(sel, 0.25), text: '#fff7ed'};
      }
      if (favorites.has(id)) {
        const fav = hexToRgb('#facc15');
        return {stroke: rgba(fav, 0.95), fill: rgba(rgb, 0.2), text: '#fefce8'};
      }
      return {
        stroke: rgba(rgb, 0.9),
        fill: rgba(rgb, 0.2),
        text: themeText || '#f8fafc',
      };
    }

    function draw() {
      if (!viewWidth || !viewHeight) return;
      const dpr = window.devicePixelRatio || 1;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, viewWidth, viewHeight);

      ctx.save();
      ctx.translate(viewWidth / 2, viewHeight / 2);
      ctx.scale(camera.scale, camera.scale);
      ctx.translate(-camera.x, -camera.y);

      const styles = getComputedStyle(document.documentElement);
      const themeText = styles.getPropertyValue('--text');
      const themeMuted = styles.getPropertyValue('--muted');

      ctx.lineWidth = Math.max(0.6, 1.1 / camera.scale);
      ctx.strokeStyle = 'rgba(148, 163, 184, 0.35)';
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      graph.forEachEdge((source, target) => {
        const from = graph.getNodeAttributes(source);
        const to = graph.getNodeAttributes(target);
        if (!from || !to) return;
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();
      });

      const textQueue = [];
      const now = performance.now();
      graph.forEachNode((id, attrs) => {
        const metrics = getNodeMetrics(id, attrs);
        const left = attrs.x - metrics.width / 2;
        const top = attrs.y - metrics.height / 2;
        const colors = computeNodeColors(id, attrs, themeText, themeMuted);

        const cornerRadius = Math.max(12, 18 * labelScale);
        ctx.fillStyle = colors.fill;
        drawRoundedRect(left, top, metrics.width, metrics.height, cornerRadius);
        ctx.fill();
        ctx.strokeStyle = colors.stroke;
        ctx.lineWidth = Math.max(1.2, 2.2 / camera.scale);
        ctx.stroke();

        if (flashNode === id) {
          if (now < flashUntil) {
            const pulse = 1 + 0.25 * Math.sin((now / 120) % (Math.PI * 2));
            const padding = (8 + metrics.paddingX * 0.2) * pulse;
            ctx.save();
            ctx.strokeStyle = 'rgba(253, 230, 138, 0.9)';
            ctx.lineWidth = Math.max(1.5, 3.2 / camera.scale);
            drawRoundedRect(left - padding, top - padding, metrics.width + padding * 2, metrics.height + padding * 2, cornerRadius + 4);
            ctx.stroke();
            ctx.restore();
          } else {
            flashNode = null;
          }
        }

        textQueue.push({id, attrs, metrics, left, top, textColor: colors.text});
      });

      ctx.restore();

      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.font = labelFont();
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      textQueue.forEach(({id, attrs, metrics, left, top, textColor}) => {
        const screen = worldToScreen(attrs.x, attrs.y);
        const screenLeft = screen.x - (metrics.width / 2) * camera.scale;
        const screenTop = screen.y - (metrics.height / 2) * camera.scale;
        if (
          screenLeft + metrics.width * camera.scale < -40 ||
          screenLeft > viewWidth + 40 ||
          screenTop + metrics.height * camera.scale < -40 ||
          screenTop > viewHeight + 40
        ) {
          return;
        }
        ctx.fillStyle = textColor;
        metrics.lines.forEach((line, index) => {
          const x = screenLeft + metrics.paddingX * camera.scale;
          const y = screenTop + metrics.paddingY * camera.scale + index * metrics.lineHeight * camera.scale;
          ctx.fillText(line, x, y);
        });
        if (favorites.has(id)) {
          ctx.fillStyle = '#facc15';
          ctx.font = `${(10 * labelScale).toFixed(2)}px ${FONT_FAMILY}`;
          const starX = screenLeft + (metrics.width - metrics.paddingX * 0.8) * camera.scale - 10 * labelScale;
          const starY = screenTop + metrics.paddingY * 0.6 * camera.scale;
          ctx.fillText('★', starX, starY);
          ctx.font = labelFont();
        }
      });
    }

    function updateNodeDetails(nodeKey) {
      if (!nodeKey || !graph.hasNode(nodeKey)) {
        nodeTitle.textContent = 'No selection';
        nodePath.textContent = '—';
        nodeChildren.textContent = '—';
        selectedNode = null;
        favoriteToggle.disabled = true;
        favoriteToggle.setAttribute('aria-pressed', 'false');
        favoriteToggle.textContent = '☆ Save to favourites';
        requestRender();
        return;
      }
      const attrs = graph.getNodeAttributes(nodeKey);
      nodeTitle.textContent = attrs.label || attrs.name || nodeKey;
      nodePath.textContent = attrs.path || attrs.label || attrs.name || 'Root';
      const childCount = graph.outDegree(nodeKey);
      if (childCount) {
        nodeChildren.textContent = `${childCount} linked ${childCount === 1 ? 'topic' : 'topics'}`;
      } else if (attrs.hasChildren) {
        nodeChildren.textContent = 'Tap node to load branch';
      } else {
        nodeChildren.textContent = 'Leaf';
      }
      const isFavorite = favorites.has(nodeKey);
      favoriteToggle.disabled = false;
      favoriteToggle.setAttribute('aria-pressed', isFavorite ? 'true' : 'false');
      favoriteToggle.textContent = isFavorite ? '★ Remove favourite' : '☆ Save to favourites';
      selectedNode = nodeKey;
      requestRender();
    }

    function animateToNode(nodeKey, options = {}) {
      if (!graph.hasNode(nodeKey)) return;
      const target = graph.getNodeAttributes(nodeKey);
      const start = {x: camera.x, y: camera.y, scale: camera.scale};
      const duration = options.duration ?? 320;
      const preserveScale = options.preserveScale ?? true;
      const endScale = options.scale !== undefined ? options.scale : (preserveScale ? start.scale : start.scale);
      const begin = performance.now();

      function step(now) {
        const t = Math.min(1, (now - begin) / duration);
        const ease = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        camera.x = start.x + (target.x - start.x) * ease;
        camera.y = start.y + (target.y - start.y) * ease;
        camera.scale = start.scale + (endScale - start.scale) * ease;
        requestRender();
        if (t < 1) {
          requestAnimationFrame(step);
        }
      }

      requestAnimationFrame(step);
    }

    function applyTheme(theme) {
      document.documentElement.dataset.theme = theme;
      themeToggle.setAttribute('aria-pressed', theme === 'dark' ? 'true' : 'false');
      localStorage.setItem('atlas-theme', theme);
      requestRender();
    }

    themeToggle.addEventListener('click', () => {
      const next = document.documentElement.dataset.theme === 'dark' ? 'light' : 'dark';
      applyTheme(next);
    });

    applyTheme(localStorage.getItem('atlas-theme') || 'dark');

    panelToggle.addEventListener('click', () => {
      const collapsed = sidePanel.dataset.collapsed === 'true';
      const nextState = !collapsed;
      sidePanel.dataset.collapsed = nextState ? 'true' : 'false';
      panelToggle.textContent = nextState ? 'Expand' : 'Collapse';
      panelToggle.setAttribute('aria-expanded', nextState ? 'false' : 'true');
    });

    favoriteToggle.addEventListener('click', () => {
      if (!selectedNode) return;
      if (favorites.has(selectedNode)) {
        favorites.delete(selectedNode);
      } else {
        favorites.add(selectedNode);
      }
      persistFavorites();
      updateFavoritesUI();
      updateNodeDetails(selectedNode);
    });

    clearFavorites.addEventListener('click', () => {
      favorites.clear();
      persistFavorites();
      updateFavoritesUI();
      updateNodeDetails(selectedNode);
    });

    fontScaleInput.value = labelScale.toString();
    fontScaleInput.addEventListener('input', () => {
      labelScale = parseFloat(fontScaleInput.value);
      nodeMetrics.clear();
      localStorage.setItem('atlas-label-scale', labelScale.toString());
      requestRender();
    });

    updateFavoritesUI();

    resetViewBtn.addEventListener('click', () => {
      if (rootId) {
        animateToNode(rootId, {scale: 0.6, preserveScale: false, duration: 420});
        updateNodeDetails(rootId);
      }
    });

    canvas.addEventListener('pointerdown', (event) => {
      isDragging = true;
      pointerMoved = false;
      dragPointerId = event.pointerId;
      lastPointer = {x: event.clientX, y: event.clientY};
      lastHoverPoint = {x: event.offsetX, y: event.offsetY};
      canvas.setPointerCapture(dragPointerId);
    });

    canvas.addEventListener('pointermove', (event) => {
      lastHoverPoint = {x: event.offsetX, y: event.offsetY};
      if (isDragging && dragPointerId === event.pointerId) {
        const dx = event.clientX - lastPointer.x;
        const dy = event.clientY - lastPointer.y;
        if (!pointerMoved && (Math.abs(dx) > 2 || Math.abs(dy) > 2)) {
          pointerMoved = true;
        }
        camera.x -= dx / camera.scale;
        camera.y -= dy / camera.scale;
        lastPointer = {x: event.clientX, y: event.clientY};
        requestRender();
      } else {
        const hovered = findNodeAt(event.offsetX, event.offsetY);
        if (hovered !== hoveredNode) {
          hoveredNode = hovered;
          requestRender();
        }
      }
    });

    function finishPointerInteraction(event) {
      if (dragPointerId !== event.pointerId) return;
      canvas.releasePointerCapture(dragPointerId);
      isDragging = false;
      dragPointerId = null;
      if (!pointerMoved) {
        const clicked = findNodeAt(lastHoverPoint.x, lastHoverPoint.y);
        if (clicked) {
          updateNodeDetails(clicked);
          animateToNode(clicked);
          ensureBranchLoaded(clicked).then(() => populateSearch());
        }
      } else {
        pointerMoved = false;
        const hovered = findNodeAt(lastHoverPoint.x, lastHoverPoint.y);
        if (hovered !== hoveredNode) {
          hoveredNode = hovered;
          requestRender();
        }
      }
    }

    canvas.addEventListener('pointerup', finishPointerInteraction);
    canvas.addEventListener('pointercancel', finishPointerInteraction);

    canvas.addEventListener('pointerleave', () => {
      if (!isDragging) {
        hoveredNode = null;
        requestRender();
      }
    });

    function handleWheel(event) {
      if (!wrapper.contains(event.target)) return;
      event.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const offsetX = event.clientX - rect.left;
      const offsetY = event.clientY - rect.top;
      const delta = event.deltaY !== undefined ? event.deltaY : -event.wheelDelta;
      const normalized = event.deltaMode === 1 ? delta * 16 : delta;
      const zoom = Math.exp(-normalized * 0.0011);
      const before = screenToWorld(offsetX, offsetY);
      camera.scale = Math.min(3.2, Math.max(0.25, camera.scale * zoom));
      const after = screenToWorld(offsetX, offsetY);
      camera.x += before.x - after.x;
      camera.y += before.y - after.y;
      requestRender();
    }

    document.addEventListener('wheel', handleWheel, {passive: false});
    document.addEventListener('mousewheel', handleWheel, {passive: false});

    function populateSearch() {
      const query = searchInput.value.trim().toLowerCase();
      searchResults.innerHTML = '';
      if (!query) {
        searchMatches = new Set();
        requestRender();
        return;
      }
      const matches = [];
      for (const [key, value] of searchIndex.entries()) {
        if (value.label.toLowerCase().includes(query)) {
          matches.push({key, label: value.label});
        }
      }
      searchMatches = new Set(matches.map(match => match.key));
      matches.slice(0, 10).forEach(match => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.textContent = inlineLabel(match.label);
        btn.setAttribute('role', 'option');
        btn.addEventListener('click', () => {
          animateToNode(match.key);
          updateNodeDetails(match.key);
          flashNode = match.key;
          flashUntil = performance.now() + 1400;
          searchResults.innerHTML = '';
          searchMatches = new Set([match.key]);
          ensureBranchLoaded(match.key).then(() => populateSearch());
          requestRender();
        });
        searchResults.append(btn);
      });
      requestRender();
    }

    searchInput.addEventListener('input', () => {
      window.requestAnimationFrame(populateSearch);
    });

    document.addEventListener('keydown', (event) => {
      const isTyping = event.target instanceof HTMLInputElement || event.target instanceof HTMLTextAreaElement;
      if (!isTyping && (event.key === '+' || event.key === '=')) {
        event.preventDefault();
        const before = screenToWorld(viewWidth / 2, viewHeight / 2);
        camera.scale = Math.min(3.2, camera.scale * 1.1);
        const after = screenToWorld(viewWidth / 2, viewHeight / 2);
        camera.x += before.x - after.x;
        camera.y += before.y - after.y;
        requestRender();
        return;
      }
      if (!isTyping && (event.key === '-' || event.key === '_')) {
        event.preventDefault();
        const before = screenToWorld(viewWidth / 2, viewHeight / 2);
        camera.scale = Math.max(0.25, camera.scale / 1.1);
        const after = screenToWorld(viewWidth / 2, viewHeight / 2);
        camera.x += before.x - after.x;
        camera.y += before.y - after.y;
        requestRender();
        return;
      }
      if (event.key === 'Escape') {
        searchResults.innerHTML = '';
        searchMatches = new Set();
        searchInput.value = '';
        requestRender();
      }
    });

    async function ensureBranchLoaded(nodeKey) {
      if (!graph.hasNode(nodeKey)) return;
      const attrs = graph.getNodeAttributes(nodeKey);
      if (!attrs.childUrl || loadedBranches.has(nodeKey)) {
        return;
      }
      if (pendingLoads.has(nodeKey)) {
        return pendingLoads.get(nodeKey);
      }
      const promise = (async () => {
        loadingIndicator.dataset.hidden = 'false';
        const readableLabel = inlineLabel(attrs.label || attrs.name || nodeKey);
        log(`Loading ${readableLabel}…`);
        const response = await fetch(attrs.childUrl);
        const payload = await response.json();
        const rootNode = graph.getNodeAttributes(nodeKey);
        const nodeLookup = new Map(payload.nodes.map(node => [node.id, node]));
        const childrenMap = new Map();
        const parentLookup = new Map(payload.edges.map(edge => [edge.target, edge.source]));
        payload.edges.forEach(edge => {
          if (!childrenMap.has(edge.source)) {
            childrenMap.set(edge.source, []);
          }
          childrenMap.get(edge.source).push(edge.target);
        });

        const leafCounts = new Map();
        function countLeaves(id) {
          const children = childrenMap.get(id) || [];
          if (!children.length) {
            leafCounts.set(id, 1);
            return 1;
          }
          let total = 0;
          children.forEach(childId => {
            total += countLeaves(childId);
          });
          leafCounts.set(id, total);
          return total;
        }
        countLeaves(payload.rootId);

        const layoutPositions = new Map();
        function layoutNode(id, depth, radius, start, end) {
          const angle = (start + end) / 2;
          const x = radius * Math.cos(angle);
          const y = radius * Math.sin(angle);
          layoutPositions.set(id, {x, y, depth});
          const children = childrenMap.get(id) || [];
          if (!children.length) return;
          const baseDistance = layoutConfig.baseLinkDistance(depth + 1);
          const rings = Math.max(1, Math.ceil(children.length / layoutConfig.childrenPerRing));
          const maxMultiplier = layoutConfig.ringMultiplier(depth + 1);
          const extraDistance = baseDistance * Math.max(0, maxMultiplier - 1);
          const ringSpacing = rings > 1 ? extraDistance / (rings - 1) : 0;
          const totalLeaves = children.reduce((sum, childId) => sum + (leafCounts.get(childId) || 1), 0);
          let cursor = start;
          children.forEach((childId, index) => {
            const leaves = leafCounts.get(childId) || 1;
            const span = totalLeaves ? (end - start) * (leaves / totalLeaves) : (end - start) / children.length;
            const childStart = cursor;
            const childEnd = cursor + span;
            const ringIndex = Math.floor(index / layoutConfig.childrenPerRing);
            const childRadius = radius + baseDistance + ringIndex * ringSpacing;
            layoutNode(childId, depth + 1, childRadius, childStart, childEnd);
            cursor = childEnd;
          });
        }

        layoutNode(payload.rootId, 0, 0, 0, Math.PI * 2);

        const baseAngle = Math.atan2(rootNode.y, rootNode.x);
        const cos = Math.cos(baseAngle);
        const sin = Math.sin(baseAngle);

        payload.nodes.forEach(node => {
          if (node.id === nodeKey) return;
          const layout = layoutPositions.get(node.id);
          if (!layout) return;
          const rotatedX = layout.x * cos - layout.y * sin;
          const rotatedY = layout.x * sin + layout.y * cos;
          const parentId = parentLookup.get(node.id) || nodeKey;
          const parent = graph.getNodeAttributes(parentId) || rootNode;
          const parentPath = parent?.path || parent?.label || parent?.name || 'Root';
          const depth = (rootNode.depth || 0) + layout.depth;
          const colorIndex = (layout.depth + (rootNode.depth || 0) + 1) % palette.length;
          if (graph.hasNode(node.id)) {
            graph.setNodeAttributes(node.id, {
              x: rotatedX + rootNode.x,
              y: rotatedY + rootNode.y,
              depth,
              label: node.name,
              path: `${parentPath} › ${node.name}`,
              color: palette[colorIndex],
              hasChildren: node.hasChildren,
            });
          } else {
            graph.addNode(node.id, {
              x: rotatedX + rootNode.x,
              y: rotatedY + rootNode.y,
              depth,
              label: node.name,
              path: `${parentPath} › ${node.name}`,
              color: palette[colorIndex],
              hasChildren: node.hasChildren,
            });
          }
          searchIndex.set(node.id, {label: node.name});
        });

        payload.edges.forEach(edge => {
          if (!graph.hasNode(edge.source) || !graph.hasNode(edge.target)) return;
          graph.addEdge(edge.source, edge.target);
        });
        loadedBranches.add(nodeKey);
        log(`Loaded ${readableLabel}`);
        updateFavoritesUI();
        requestRender();
      })().finally(() => {
        loadingIndicator.dataset.hidden = 'true';
        pendingLoads.delete(nodeKey);
      });
      pendingLoads.set(nodeKey, promise);
      return promise;
    }

    async function bootstrap() {
      loadingIndicator.dataset.hidden = 'false';
      const rootData = await fetch('data/root.json').then(r => r.json());
      rootId = rootData.root.id;
      graph.addNode(rootData.root.id, {
        x: rootData.root.x,
        y: rootData.root.y,
        depth: rootData.root.depth,
        label: rootData.root.name,
        path: rootData.root.name,
        color: palette[0],
        hasChildren: true
      });
      searchIndex.set(rootData.root.id, {label: rootData.root.name});
      rootData.children.forEach((child, index) => {
        graph.addNode(child.id, {
          x: child.x,
          y: child.y,
          depth: child.depth,
          label: child.name,
          path: `${rootData.root.name} › ${child.name}`,
          color: palette[(index + 1) % palette.length],
          childUrl: child.childUrl,
          hasChildren: child.hasChildren
        });
        graph.addEdge(rootData.root.id, child.id);
      searchIndex.set(child.id, {label: child.name});
    });
    resizeCanvas();
    updateNodeDetails(rootData.root.id);
    updateFavoritesUI();
    animateToNode(rootData.root.id, {scale: camera.scale, preserveScale: false, duration: 600});
    loadingIndicator.dataset.hidden = 'true';
    log('Atlas ready. Click a macro node to stream its branch.');
    requestRender();
  }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    renderLoop();
    bootstrap();
  })();
  </script>
</body>
</html>
